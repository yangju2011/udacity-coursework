# THREE GOLD STARS
# Question 3-star: Elementary Cellular Automaton

# Please see the video for additional explanation.

# A one-dimensional cellular automata takes in a string, which in our 
# case, consists of the characters '.' and 'x', and changes it according 
# to some predetermined rules. The rules consider three characters, which 
# are a character at position k and its two neighbours, and determine 
# what the character at the corresponding position k will be in the new 
# string.

# For example, if the character at position k in the string  is '.' and 
# its neighbours are '.' and 'x', then the pattern is '..x'. We look up 
# '..x' in the table below. In the table, '..x' corresponds to 'x' which 
# means that in the new string, 'x' will be at position k.

# Rules:
#          pattern in         position k in        contribution to
# Value    current string     new string           pattern number
#                                                  is 0 if replaced by '.'
#                                                  and value if replaced
#                                                  by 'x'
#   1       '...'               '.'                        1 * 0
#   2       '..x'               'x'                        2 * 1
#   4       '.x.'               'x'                        4 * 1
#   8       '.xx'               'x'                        8 * 1
#  16       'x..'               '.'                       16 * 0
#  32       'x.x'               '.'                       32 * 0
#  64       'xx.'               '.'                       64 * 0
# 128       'xxx'               'x'                      128 * 1
#                                                      ----------
#                                                           142

# To calculate the patterns which will have the central character x, work 
# out the values required to sum to the pattern number. For example,
# 32 = 32 so only pattern 32 which is x.x changes the central position to
# an x. All the others have a . in the next line.

# 23 = 16 + 4 + 2 + 1 which means that 'x..', '.x.', '..x' and '...' all 
# lead to an 'x' in the next line and the rest have a '.'

# For pattern 142, and starting string
# ...........x...........
# the new strings created will be
# ..........xx...........  (generations = 1)
# .........xx............  (generations = 2)
# ........xx.............  (generations = 3)
# .......xx..............  (generations = 4)
# ......xx...............  (generations = 5)
# .....xx................  (generations = 6)
# ....xx.................  (generations = 7)
# ...xx..................  (generations = 8)
# ..xx...................  (generations = 9)
# .xx....................  (generations = 10)

# Note that the first position of the string is next to the last position 
# in the string.

# Define a procedure, cellular_automaton, that takes three inputs: 
#     a non-empty string, 
#     a pattern number which is an integer between 0 and 255 that
# represents a set of rules, and 
#     a positive integer, n, which is the number of generations. 
# The procedure should return a string which is the result of
# applying the rules generated by the pattern to the string n times.

def cellular_automaton(s,pattern,generation):
    #pattern is a number to be divided by 2**(0-7)
    #return p represents when pattern generates 'X'
    p=[0,0,0,0,0,0,0,0] 
    #could be compile 2**i, i range (0,7)
    # if pattern%2**i==0:change pattern to 'x', else to '.'
    #could also create pattern list
    if pattern>=128:
        p[7]=1
        pattern=pattern-128
    if pattern>=64:
        p[6]=1
        pattern=pattern-64
    if pattern>=32:
        p[5]=1
        pattern=pattern-32
    if pattern>=16:
        p[4]=1
        pattern=pattern-16
    if pattern>=8:
        p[3]=1
        pattern=pattern-8
    if pattern>=4:
        p[2]=1
        pattern=pattern-4
    if pattern>=2:
        p[1]=1
        pattern=pattern-2
    p[0]=pattern
    
    #convert to code
    code=[[1,'...',p[0]],[2,'..x',p[1]],[4,'.x.',p[2]],[8,'.xx',p[3]],[16,'x..',p[4]],[32,'x.x' ,p[5]],[64,'xx.',p[6]],[128,'xxx',p[7]]]
    for e in code:
        if e[2]==1:
            e.append('x')
        else:
            e.append('.')
    
    #make dictionary with new code
    dicts={}
    for e in code:
        dicts[e[1]]=e[3] #key is a string
    
    #convert string s to generation, at position k
    n=len(s) #s is not empty, length is not changed
    g=0
    while g<generation:
        k=0
        news=''
        if n==1:
            sn=s+s+s
            sk=dicts[sn] #at location k
            news=news+sk #has only one letter in the string
        if n>1:
            while k<n:
                if k==0:
                    sn=s[-1]+s[0]+s[1]
                if k<n-1:
                    sn=s[k-1]+s[k]+s[k+1]
                if k==n-1:
                    sn=s[k-1]+s[k]+s[0] #the last element could be (k+1)%n, if k+1<n, return k+1, else, for k=n-1, return 0!! smart. 
                sk=dicts[sn]
                #if replace sk here, the next element in the string will be affected
                #the next value depends on the origina s, s should be be changed, the new value shall be stored by itself
                news=news+sk
                k=k+1
        s=news
        g=g+1
        #generate new string news in generation 1
        #then for generation later, replace s=news
    return s


print cellular_automaton('.x.x.x.x.', 17, 2)
#>>> xxxxxxx..
print cellular_automaton('.x.x.x.x.', 249, 3)
#>>> .x..x.x.x
print cellular_automaton('...x....', 125, 1)
#>>> xx.xxxxx
print cellular_automaton('...x....', 125, 2)
#>>> .xxx....
print cellular_automaton('...x....', 125, 3)
#>>> .x.xxxxx
print cellular_automaton('...x....', 125, 4)
#>>> xxxx...x
print cellular_automaton('...x....', 125, 5)
#>>> ...xxx.x
print cellular_automaton('...x....', 125, 6)
#>>> xx.x.xxx
print cellular_automaton('...x....', 125, 7)
#>>> .xxxxx..
print cellular_automaton('...x....', 125, 8)
#>>> .x...xxx
print cellular_automaton('...x....', 125, 9)
#>>> xxxx.x.x
print cellular_automaton('...x....', 125, 10)
#>>> ...xxxxx

